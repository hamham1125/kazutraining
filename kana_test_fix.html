<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ã²ã‚‰ãŒãªãƒ»ã‚«ã‚¿ã‚«ãƒŠ ãƒ†ã‚¹ãƒˆ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* ========= å…±é€šï¼ˆã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆç·´ç¿’ã¨åŒç³»çµ±ã®è¦‹ãŸç›®ï¼‰ ========= */
    body { background:#fff7dc; font-family:'Rounded Mplus 1c', system-ui, -apple-system, Segoe UI, sans-serif; text-align:center; margin:0; padding:54px 10px 30px; }
    h1 { font-size:2em; margin:0 0 14px; }

    /* ãƒœã‚¿ãƒ³é¡ï¼ˆã‚¯ãƒªãƒƒã‚¯æŠ¼ã—è¾¼ã¿è¡¨ç¾ï¼‰ */
    .audio-button, .nav-button, .option { cursor:pointer; user-select:none; transition: transform .08s ease, box-shadow .08s ease; }
    .audio-button { font-size:1.05em; padding:8px 14px; border-radius:12px; border:none; background:#ffca28; box-shadow:0 4px 0 #f0b400; }
    .nav-button { font-size:1em; padding:10px 16px; border:none; border-radius:10px; background:#ccc; box-shadow:0 3px 0 #bdbdbd; }
    .option { min-width:120px; min-height:72px; font-size:2rem; padding:10px 16px; border:none; border-radius:16px; background:#fff; box-shadow:0 4px 0 #bdbdbd; }
    .audio-button:active, .nav-button:active, .option:active { transform: translateY(2px) scale(0.98); box-shadow:0 2px 0 rgba(0,0,0,.2); }

    /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ï¼ˆ1è¡Œã€‚ç‹­ã„ç”»é¢ã¯æŠ˜è¿”ã—ï¼‰ */
    .controls { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; align-items:center; background:rgba(255,255,255,.88); padding:10px 12px; border-radius:14px; box-shadow:0 2px 0 rgba(0,0,0,.1); }
    .controls select { font-size:1rem; padding:8px 12px; border-radius:10px; background:#fff; border:1px solid #ddd; }
    .spacer { width:8px; height:1px; }

    .questionWrap { margin-top:18px; }
    .bigNotice { font-size:1.1em; color:#333; margin:6px 0 12px; }

    /* 5æŠã‚¨ãƒªã‚¢ */
    .options { display:flex; justify-content:center; flex-wrap:wrap; gap:16px; margin-top:12px; }

    /* æ‰‹æ›¸ãã‚¨ãƒªã‚¢ */
    .drawWrap { display:none; margin:10px auto 0; max-width:360px; }
    .canvasBox { position:relative; margin:0 auto; width:320px; height:320px; background:#fff; border-radius:12px; box-shadow:inset 0 0 0 2px #333; }
    /* Ensure canvas appears above the grid overlay by setting z-index */
    canvas {
      position: relative;
      z-index: 1;
      width: 320px;
      height: 320px;
      touch-action: none;
      display: block;
      background: #fff;
    }
    /* 4åˆ†å‰²ã‚¬ã‚¤ãƒ‰ */
    /* Draw the guideline grid behind the canvas. The z-index ensures it does not cover drawn lines. */
    .grid::before { content:""; position:absolute; inset:0; pointer-events:none; z-index:0; background:
      linear-gradient(#ddd 1px, transparent 1px) 0 50%/100% 1px,
      linear-gradient(90deg, #ddd 1px, transparent 1px) 50% 0/1px 100%; }

    .drawTools { display:flex; justify-content:center; gap:8px; margin-top:10px; flex-wrap:wrap; align-items:center; }
    .label { font-size:.95em; opacity:.85; }

    /* ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆã€‡Ã—ï¼‰ */
    #feedback { font-size:4.6em; color:#e60000; line-height:1; display:none; margin:10px 0; text-shadow:0 2px 4px rgba(0,0,0,.15); }

    /* çµæœ */
    #resultPanel { margin-top:16px; font-size:1.1em; }

    /* è¨˜éŒ²ãƒªãƒ¼ãƒ€ï¼ˆå·¦ä¸Šå›ºå®šï¼‰ */
    #recordToggle { position:fixed; top:10px; left:10px; background:#ffd54f; padding:8px 12px; border-radius:10px; font-size:1em; z-index:1000; border:none; box-shadow:0 3px 0 #f0b400; cursor:pointer; }
    #recordPanel { position:fixed; top:52px; left:10px; width:min(92vw, 360px); max-height:80vh; overflow:auto; background:#fff; border:2px solid #e0c36a; border-radius:12px; padding:12px; text-align:left; display:none; z-index:1000; }
    #recordPanel h3 { margin:6px 0 8px; }
    .recItem { border:1px solid #eee; padding:8px; border-radius:8px; margin-bottom:8px; background:#fafafa; }
    .recItem summary { cursor:pointer; }

    /* è¨­å®šãƒ€ã‚¤ã‚¢ãƒ­ã‚° */
    dialog#settings { border:none; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.25); padding:16px; }
    #settings .row { display:flex; align-items:center; gap:10px; }
    #settings input[type=range] { width:200px; }

    .footer { margin-top:22px; }
  </style>
</head>
<body>
  <!-- è¨˜éŒ²ãƒˆã‚°ãƒ« -->
  <button id="recordToggle">ğŸ“Š ãã‚ã</button>
  <div id="recordPanel">
    <h3>ãã‚ãï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ï¼‰</h3>
    <div style="display:flex; gap:8px; margin-bottom:8px;">
      <button class="nav-button" id="refreshRec">âŸ³ æ›´æ–°</button>
      <button class="nav-button" id="clearRec" style="background:#ffb3b3">ğŸ—‘ ãœã‚“ã¶æ¶ˆã™</button>
    </div>
    <div id="recordList"></div>
  </div>

  <!-- æ¡ç‚¹å¾…ã¡ãƒ‘ãƒãƒ«ï¼ˆè¨˜éŒ²ã¨ã¯åˆ¥ã«è¡¨ç¤ºï¼‰ -->
  <div id="pendingPanel" style="position:fixed; top:52px; right:10px; width:min(92vw, 360px); max-height:80vh; overflow:auto; background:#fff; border:2px solid #e0c36a; border-radius:12px; padding:12px; text-align:left; display:none; z-index:1000;">
    <h3 style="margin:6px 0 8px;">æ¡ç‚¹å¾…ã¡</h3>
    <div id="pendingList"></div>
  </div>

  <h1>ã²ã‚‰ãŒãªãƒ»ã‚«ã‚¿ã‚«ãƒŠ ãƒ†ã‚¹ãƒˆ</h1>
  <div class="controls">
    <button id="startBtn" class="nav-button">â–¶ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    <button id="resetBtn" class="nav-button">â†º ãƒªã‚»ãƒƒãƒˆ</button>
    <div class="spacer"></div>
    <label class="label">æ–‡å­—ç¨®ï¼š</label>
    <select id="scriptSel">
      <option value="hira">ã²ã‚‰ãŒãª</option>
      <option value="kata">ã‚«ã‚¿ã‚«ãƒŠ</option>
    </select>
    <label class="label">ã‚»ãƒƒãƒˆï¼š</label>
    <select id="setSel">
      <option value="seion">æ¸…éŸ³</option>
      <option value="dakuon">æ¿éŸ³</option>
      <option value="handakuon">åŠæ¿éŸ³</option>
      <option value="yoon">æ‹—éŸ³</option>
      <option value="all">ãœã‚“ã¶</option>
    </select>
    <label class="label">ãƒ¢ãƒ¼ãƒ‰ï¼š</label>
    <select id="modeSel">
      <option value="choice">5æŠ</option>
      <option value="hand">æ‰‹æ›¸ã</option>
    </select>
    <label class="label">æ¡ç‚¹ï¼š</label>
    <select id="evalSel">
      <option value="auto">AIåˆ¤å®š</option>
      <option value="teacher">å…ˆç”Ÿæ¡ç‚¹</option>
    </select>
    <button id="openSettings" class="nav-button" title="åˆ¤å®šã®ã‚„ã•ã—ã•">âš™ è¨­å®š</button>
    <!-- æ–°ã—ã„æ¡ç‚¹å¾…ã¡ãƒœã‚¿ãƒ³ -->
    <button id="pendingToggle" class="nav-button" title="æ¡ç‚¹å¾…ã¡ã®ä¸€è¦§">ğŸ“ æ¡ç‚¹å¾…ã¡</button>
  </div>

  <div class="questionWrap">
    <div class="bigNotice" id="prompt">ãŠã¨ã‚’ãã„ã¦ã€€ãˆã‚‰ã‚“ã§ã­ / ã‹ã„ã¦ã­</div>
    <div style="margin-bottom:10px; display:flex; justify-content:center; gap:8px; flex-wrap:wrap;">
      <button class="audio-button" id="playBtn">â–¶ ãŠã¨ã‚’ãã</button>
      <button class="audio-button" id="replayBtn" style="display:none">â–¶ ã‚‚ã†ã„ã£ã‹ã„</button>
    </div>

    <!-- 5æŠ -->
    <div id="choiceArea" class="options"></div>

    <!-- æ‰‹æ›¸ã -->
    <div id="handArea" class="drawWrap">
      <div class="canvasBox grid">
        <canvas id="draw"></canvas>
      </div>
      <div class="drawTools">
        <button class="nav-button" id="undoBtn">â†© 1ã¤æˆ»ã™</button>
        <button class="nav-button" id="clearBtn">ğŸ§½ ãœã‚“ã¶æ¶ˆã™</button>
        <!-- In AI mode, autoBtn will perform auto judgement; in teacher mode, submitBtn will submit the drawing for teacher grading -->
        <button class="audio-button" id="autoBtn">ã“ãŸãˆ</button>
        <button class="nav-button" id="submitBtn">ã¦ã„ã—ã‚…ã¤</button>
      </div>
    </div>

    <div id="feedback">ã€‡</div>
    <div id="progress" class="bigNotice"></div>
    <div id="resultPanel"></div>
  </div>

  <!-- è¨­å®šãƒ€ã‚¤ã‚¢ãƒ­ã‚° -->
  <dialog id="settings">
    <form method="dialog">
      <h3 style="margin-top:0">âš™ è¨­å®š</h3>
      <div class="row" style="margin:8px 0 12px;">
        <label style="min-width:6em">ã‚„ã•ã—ã•</label>
        <input type="range" id="leniency" min="1" max="5" step="1" value="4" />
        <span id="lenVal">4</span>
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end">
        <button class="nav-button" value="cancel">ã¨ã˜ã‚‹</button>
        <button class="nav-button" id="saveSettings" value="default">ä¿å­˜</button>
      </div>
    </form>
  </dialog>

  <script>
  // Data
  const KANA = {
    hira: {
      seion: ['ã‚','ã„','ã†','ãˆ','ãŠ','ã‹','ã','ã','ã‘','ã“','ã•','ã—','ã™','ã›','ã','ãŸ','ã¡','ã¤','ã¦','ã¨','ãª','ã«','ã¬','ã­','ã®','ã¯','ã²','ãµ','ã¸','ã»','ã¾','ã¿','ã‚€','ã‚','ã‚‚','ã‚„','ã‚†','ã‚ˆ','ã‚‰','ã‚Š','ã‚‹','ã‚Œ','ã‚','ã‚','ã‚’','ã‚“'],
      dakuon: ['ãŒ','ã','ã','ã’','ã”','ã–','ã˜','ãš','ãœ','ã','ã ','ã¢','ã¥','ã§','ã©','ã°','ã³','ã¶','ã¹','ã¼'],
      handakuon: ['ã±','ã´','ã·','ãº','ã½'],
      yoon: ['ãã‚ƒ','ãã‚…','ãã‚‡','ã—ã‚ƒ','ã—ã‚…','ã—ã‚‡','ã¡ã‚ƒ','ã¡ã‚…','ã¡ã‚‡','ã«ã‚ƒ','ã«ã‚…','ã«ã‚‡','ã²ã‚ƒ','ã²ã‚…','ã²ã‚‡','ã¿ã‚ƒ','ã¿ã‚…','ã¿ã‚‡','ã‚Šã‚ƒ','ã‚Šã‚…','ã‚Šã‚‡','ãã‚ƒ','ãã‚…','ãã‚‡','ã˜ã‚ƒ','ã˜ã‚…','ã˜ã‚‡','ã³ã‚ƒ','ã³ã‚…','ã³ã‚‡','ã´ã‚ƒ','ã´ã‚…','ã´ã‚‡']
    },
    kata: {
      seion: ['ã‚¢','ã‚¤','ã‚¦','ã‚¨','ã‚ª','ã‚«','ã‚­','ã‚¯','ã‚±','ã‚³','ã‚µ','ã‚·','ã‚¹','ã‚»','ã‚½','ã‚¿','ãƒ','ãƒ„','ãƒ†','ãƒˆ','ãƒŠ','ãƒ‹','ãƒŒ','ãƒ','ãƒ','ãƒ','ãƒ’','ãƒ•','ãƒ˜','ãƒ›','ãƒ','ãƒŸ','ãƒ ','ãƒ¡','ãƒ¢','ãƒ¤','ãƒ¦','ãƒ¨','ãƒ©','ãƒª','ãƒ«','ãƒ¬','ãƒ­','ãƒ¯','ãƒ²','ãƒ³'],
      dakuon: ['ã‚¬','ã‚®','ã‚°','ã‚²','ã‚´','ã‚¶','ã‚¸','ã‚º','ã‚¼','ã‚¾','ãƒ€','ãƒ‚','ãƒ…','ãƒ‡','ãƒ‰','ãƒ','ãƒ“','ãƒ–','ãƒ™','ãƒœ'],
      handakuon: ['ãƒ‘','ãƒ”','ãƒ—','ãƒš','ãƒ'],
      yoon: ['ã‚­ãƒ£','ã‚­ãƒ¥','ã‚­ãƒ§','ã‚·ãƒ£','ã‚·ãƒ¥','ã‚·ãƒ§','ãƒãƒ£','ãƒãƒ¥','ãƒãƒ§','ãƒ‹ãƒ£','ãƒ‹ãƒ¥','ãƒ‹ãƒ§','ãƒ’ãƒ£','ãƒ’ãƒ¥','ãƒ’ãƒ§','ãƒŸãƒ£','ãƒŸãƒ¥','ãƒŸãƒ§','ãƒªãƒ£','ãƒªãƒ¥','ãƒªãƒ§','ã‚®ãƒ£','ã‚®ãƒ¥','ã‚®ãƒ§','ã‚¸ãƒ£','ã‚¸ãƒ¥','ã‚¸ãƒ§','ãƒ“ãƒ£','ãƒ“ãƒ¥','ãƒ“ãƒ§','ãƒ”ãƒ£','ãƒ”ãƒ¥','ãƒ”ãƒ§']
    }
  };
  function buildPool(s, set){ const d = KANA[s]; return (set==='all') ? [...d.seion, ...d.dakuon, ...d.handakuon, ...d.yoon] : [...d[set]]; }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  // State
  let script = 'hira';
  let setKind = 'seion';
  let mode = 'choice';
  let evalMethod = 'auto';
  let pool = [];
  let queue = [];
  let qIndex = -1;
  let current = '';
  let running = false;
  let correct = 0, wrong = 0, maybe = 0;
  const wrongMap = new Map();

  // Submission storage (for teacher grading)
  const SUB_KEY = 'kana_test_submissions_v1';

  // Aggregated session storage for teacher grading
  const AGG_KEY = 'kana_test_aggregators_v1';

  // Session context for current test (teacher mode)
  let currentSessionId = null;
  let currentTotal = 0;

  // Load aggregators map from storage
  function loadAggregators() {
    try {
      return JSON.parse(localStorage.getItem(AGG_KEY) || '{}');
    } catch (e) {
      return {};
    }
  }

  // Save aggregators map to storage
  function saveAggregators(obj) {
    try {
      localStorage.setItem(AGG_KEY, JSON.stringify(obj));
    } catch (e) {}
  }

  // Update or create aggregator entry for a graded submission
  function updateAggregatorForSubmission(sub, grade) {
    const aggs = loadAggregators();
    let agg = aggs[sub.sessionId];
    if (!agg) {
      // Create new aggregator for this session
      agg = {
        date: sub.date,
        script: sub.script,
        setKind: sub.setKind,
        mode: 'hand',
        total: sub.total || 1,
        gradedCount: 0,
        correct: 0,
        wrong: 0,
        maybe: 0,
        wrongs: {}
      };
      aggs[sub.sessionId] = agg;
    }
    // Update counts based on grade
    agg.gradedCount++;
    if (grade === 'good') {
      agg.correct++;
    } else if (grade === 'bad') {
      agg.wrong++;
      agg.wrongs[sub.char] = (agg.wrongs[sub.char] || 0) + 1;
    } else if (grade === 'maybe') {
      agg.maybe++;
      agg.wrongs[sub.char] = (agg.wrongs[sub.char] || 0) + 1;
    }
    saveAggregators(aggs);
    // Check if the session is fully graded
    if (agg.gradedCount >= agg.total) {
      // Build aggregated record
      const wrongArr = Object.entries(agg.wrongs).map(([ch, n]) => ({ ch, n })).sort((a, b) => b.n - a.n);
      const rec = {
        date: agg.date,
        script: agg.script,
        setKind: agg.setKind,
        mode: 'hand',
        total: agg.total,
        correct: agg.correct,
        wrong: agg.wrong,
        maybe: agg.maybe,
        wrongs: wrongArr
      };
      // Save aggregated record
      saveRecord(rec);
      // Remove aggregator entry
      delete aggs[sub.sessionId];
      saveAggregators(aggs);
    }
  }

  function loadSubmissions() {
    try {
      return JSON.parse(localStorage.getItem(SUB_KEY) || '[]');
    } catch (e) {
      return [];
    }
  }

  function saveSubmissions(arr) {
    try {
      localStorage.setItem(SUB_KEY, JSON.stringify(arr));
    } catch (e) {}
  }

  function addSubmission(sub) {
    const arr = loadSubmissions();
    arr.push(sub);
    saveSubmissions(arr);
  }

  // Grade a submission and persist as a record
  function gradeSubmission(sub, grade) {
    // Remove from submissions list
    let arr = loadSubmissions();
    arr = arr.filter(s => s.id !== sub.id);
    saveSubmissions(arr);
    // Update aggregator for this submission
    updateAggregatorForSubmission(sub, grade);
    // Refresh displays
    renderRecords();
    renderPending();
  }
  // Elements
  const scriptSel = document.getElementById('scriptSel');
  const setSel = document.getElementById('setSel');
  const modeSel = document.getElementById('modeSel');
  const evalSel = document.getElementById('evalSel');
  const startBtn = document.getElementById('startBtn');
  const resetBtn = document.getElementById('resetBtn');
  const promptEl = document.getElementById('prompt');
  const choiceArea = document.getElementById('choiceArea');
  const handArea = document.getElementById('handArea');
  const submitBtn = document.getElementById('submitBtn');
  const playBtn = document.getElementById('playBtn');
  const replayBtn = document.getElementById('replayBtn');
  const feedbackEl = document.getElementById('feedback');
  const progressEl = document.getElementById('progress');
  const resultPanel = document.getElementById('resultPanel');
  // Canvas
  const canvas = document.getElementById('draw');
  const ctx = canvas.getContext('2d');
  const undoBtn = document.getElementById('undoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const autoBtn = document.getElementById('autoBtn');
  // Manual mark buttons have been removed; placeholders kept for compatibility (null)
  const markGood = null;
  const markMaybe = null;
  const markBad = null;
  const leniencyRange = document.getElementById('leniency');
  const lenVal = document.getElementById('lenVal');
  // Add explicit references for the settings dialog and its buttons to avoid reliance on global variables.
  const settingsDlg = document.getElementById('settings');
  const openSettingsBtn = document.getElementById('openSettings');
  const saveSettingsBtn = document.getElementById('saveSettings');

  // Elements related to grading pending list
  const pendingToggle = document.getElementById('pendingToggle');
  const pendingPanel = document.getElementById('pendingPanel');
  const pendingList = document.getElementById('pendingList');
  // Utils
  function speakKana(text){ try{ if(window.speechSynthesis){ speechSynthesis.cancel(); } const u = new SpeechSynthesisUtterance(text==='ãƒ²'?'ã‚’':text); u.lang='ja-JP'; speechSynthesis.speak(u);}catch(e){} }
  function showFeedback(mark){ feedbackEl.textContent=mark; feedbackEl.style.display='block'; setTimeout(()=>{ feedbackEl.style.display='none'; },520); }
  function updateProgress(){ progressEl.textContent = running? `ã‚‚ã‚“ã ã„ï¼š${qIndex+1}/${queue.length}` : ''; }
  // Canvas functions
  function ensureCanvasReady(){ const cs = getComputedStyle(canvas); const cssW = Math.max(1, parseFloat(cs.width) || canvas.offsetWidth || 320); const cssH = Math.max(1, parseFloat(cs.height) || canvas.offsetHeight || 320); const needW=Math.floor(cssW); const needH=Math.floor(cssH); if(canvas.width!==needW || canvas.height!==needH){ canvas.width=needW; canvas.height=needH; } }
  let drawing = false, paths = [], currentPath = [];
  function redraw(){ ensureCanvasReady(); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.globalAlpha=1; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#000'; ctx.lineWidth=14; function drawPath(p){ if(!p.length) return; ctx.beginPath(); ctx.moveTo(p[0].x, p[0].y); for(let i=1;i<p.length;i++){ ctx.lineTo(p[i].x, p[i].y); } ctx.stroke(); }
    for(const p of paths) drawPath(p);
    drawPath(currentPath);
  }
  function cssPoint(e){ const r=canvas.getBoundingClientRect(); const cx=(e.clientX ?? (e.touches? e.touches[0].clientX:0)); const cy=(e.clientY ?? (e.touches? e.touches[0].clientY:0)); return { x: cx - r.left, y: cy - r.top }; }
  function startDraw(e){ if(e.cancelable) e.preventDefault(); ensureCanvasReady(); drawing=true; currentPath=[cssPoint(e)]; }
  function moveDraw(e){ if(!drawing) return; if(e.cancelable) e.preventDefault(); currentPath.push(cssPoint(e)); redraw(); }
  function endDraw(e){ if(!drawing) return; if(e.cancelable) e.preventDefault(); drawing=false; paths.push(currentPath); currentPath=[]; redraw(); }
  // Pointer and fallback
  canvas.addEventListener('pointerdown', e=>{ startDraw(e); canvas.setPointerCapture?.(e.pointerId); });
  canvas.addEventListener('pointermove', moveDraw);
  canvas.addEventListener('pointerup', endDraw);
  canvas.addEventListener('pointercancel', () => { drawing=false; currentPath=[]; });
  canvas.addEventListener('touchstart', startDraw, {passive:false});
  canvas.addEventListener('touchmove', moveDraw, {passive:false});
  canvas.addEventListener('touchend', endDraw, {passive:false});
  canvas.addEventListener('mousedown', startDraw);
  window.addEventListener('mousemove', moveDraw);
  window.addEventListener('mouseup', endDraw);
  undoBtn.onclick=()=>{ if(paths.length){ paths.pop(); redraw(); } };
  clearBtn.onclick=()=>{ paths=[]; redraw(); };
  // Automatic judgement thresholds
  function thresholds(){ const v=parseInt(localStorage.getItem('kana_leniency')||leniencyRange.value,10)||4; const table={1:[0.35,0.25],2:[0.26,0.18],3:[0.20,0.12],4:[0.15,0.09],5:[0.10,0.06]}; return table[v]||table[4]; }
  function safeGetImageData(c,x,y,w,h){ try{ return c.getImageData(x,y,w,h);}catch(err){ ensureCanvasReady(); try{ return c.getImageData(x,y,w,h);}catch(e2){ return null; } } }
  function autoJudge(){ let w=canvas.width,h=canvas.height; if(w<1||h<1){ ensureCanvasReady(); w=canvas.width; h=canvas.height; if(w<1||h<1) return {ok:false, ratioA:0, ratioB:0}; } const drawnIm = safeGetImageData(ctx,0,0,w,h); if(!drawnIm) return {ok:false, ratioA:0, ratioB:0}; const data=drawnIm.data; let drawnCount=0; const m1=new Uint8Array(w*h); for(let i=0;i<w*h;i++){ const a=data[i*4+3]; if(a>20){ m1[i]=1; drawnCount++; } } if(drawnCount<120) return {ok:false, ratioA:0, ratioB:0}; const off=document.createElement('canvas'); off.width=w; off.height=h; const o=off.getContext('2d'); o.fillStyle='#000'; const fBase=(current.length>=2)? Math.floor(h*0.55) : Math.floor(h*0.68); o.font=`normal ${fBase}px \"Yu Gothic\", \"Noto Sans JP\", sans-serif`; o.textAlign='center'; o.textBaseline='middle'; o.fillText(current,w/2,h/2+4); const glyphIm = safeGetImageData(o,0,0,w,h); if(!glyphIm) return {ok:false, ratioA:0, ratioB:0}; const g=glyphIm.data; let glyphCount=0; const m2=new Uint8Array(w*h); for(let i=0;i<w*h;i++){ const a=g[i*4+3]; const sum=g[i*4]+g[i*4+1]+g[i*4+2]; if(a>10 && sum<720){ m2[i]=1; glyphCount++; } } if(glyphCount<200) return {ok:false, ratioA:0, ratioB:0}; let overlap=0; for(let i=0;i<w*h;i++){ if(m1[i] && m2[i]) overlap++; } const ratioA=overlap/drawnCount; const ratioB=overlap/glyphCount; const [thA, thB] = thresholds(); return { ok:(ratioA>=thA && ratioB>=thB), ratioA, ratioB };
  }
  function mark(kind){ if(!running) return; if(kind==='good'){ correct++; showFeedback('ã€‡'); } else if(kind==='maybe'){ maybe++; showFeedback('â–³'); wrongMap.set(current, (wrongMap.get(current)||0)+1); } else { wrong++; showFeedback('Ã—'); wrongMap.set(current, (wrongMap.get(current)||0)+1); } nextQuestion(); }
  // Auto judgement button
  autoBtn.onclick=()=>{
    if(!running || evalMethod !== 'auto') return;
    const r = autoJudge();
    if(r.ok) mark('good');
    else mark('bad');
  };
  // manual mark buttons no longer exist
  // 5-choice rendering
  function renderChoice(){ choiceArea.innerHTML=''; const opts = new Set([current]); if(pool.length<=5){ pool.forEach(ch=>opts.add(ch)); } else { while(opts.size<5){ const pick = pool[Math.floor(Math.random()*pool.length)]; if(pick!==current) opts.add(pick); } } const list = shuffle([...opts]).slice(0, Math.min(5, pool.length)); list.forEach(opt=>{ const b=document.createElement('button'); b.className='option'; b.textContent=opt; b.onclick=()=>{ if(opt===current){ correct++; showFeedback('ã€‡'); nextQuestion(); } else { wrong++; showFeedback('Ã—'); wrongMap.set(current,(wrongMap.get(current)||0)+1); } }; choiceArea.appendChild(b); }); }
  // Quiz control
  function nextQuestion(){
    qIndex++;
    updateProgress();
    if(qIndex >= queue.length){
      finish();
      return;
    }
    current = queue[qIndex];
    speakKana(current);
    feedbackEl.style.display = 'none';
    if(mode === 'choice'){
      // show multiple choice buttons
      choiceArea.style.display = 'flex';
      handArea.style.display = 'none';
      renderChoice();
    } else {
      // hand writing mode
      choiceArea.style.display = 'none';
      handArea.style.display = 'block';
      // reset drawn paths
      paths = [];
      // toggle buttons based on evaluation method
      if(evalMethod === 'auto'){
        autoBtn.style.display = 'inline-block';
        submitBtn.style.display = 'none';
      } else {
        autoBtn.style.display = 'none';
        submitBtn.style.display = 'inline-block';
      }
      requestAnimationFrame(() => {
        ensureCanvasReady();
        redraw();
      });
    }
    replayBtn.style.display = running ? 'inline-block' : 'none';
  }
  function start(){
    script = scriptSel.value;
    setKind = setSel.value;
    mode = modeSel.value;
    evalMethod = evalSel ? evalSel.value : 'auto';
    pool = buildPool(script, setKind);
    queue = shuffle([...pool]);
    qIndex = -1;
    running = true;
    correct = 0;
    wrong = 0;
    maybe = 0;
    wrongMap.clear();
    resultPanel.innerHTML = '';
    // Assign a new session ID and total for teacher hand-writing tests
    if (mode === 'hand' && evalMethod === 'teacher') {
      currentSessionId = Date.now().toString() + Math.random().toString(36).slice(2);
      currentTotal = pool.length;
    } else {
      currentSessionId = null;
      currentTotal = 0;
    }
    promptEl.textContent = (mode === 'choice') ? 'ãŠã¨ã‚’ãã„ã¦ã€€ãˆã‚‰ã‚“ã§ã­' : 'ãŠã¨ã‚’ãã„ã¦ã€€ã‹ã„ã¦ã­';
    nextQuestion();
  }
  function resetAll(){ running=false; choiceArea.innerHTML=''; handArea.style.display='none'; choiceArea.style.display='none'; progressEl.textContent=''; feedbackEl.style.display='none'; resultPanel.innerHTML=''; try{ if(window.speechSynthesis) speechSynthesis.cancel(); }catch(e){} }
  function finish(){
    if(!running){ return; }
    running = false;
    try{ if(window.speechSynthesis) speechSynthesis.cancel(); }catch(e){}
    // Build result string for UI
    const wrongLines = Array.from(wrongMap.entries()).sort((a,b) => b[1] - a[1]).map(([k,v]) => `${k}ï¼š${v}å›`).join('ã€€');
    resultPanel.innerHTML = `<div style="margin-top:14px; font-size:1.1em;"><div><strong>ã‘ã£ã‹</strong>ã€€ã€‡ï¼š${correct}ã€€Ã—ï¼š${wrong}ã€€â–³ï¼š${maybe}</div><div style="margin-top:8px;"><strong>ã¾ã¡ãŒãˆãŸæ–‡å­—</strong>ï¼š${wrongLines || 'ãªã—'}</div><div style="margin-top:10px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap;"><button class=\"nav-button\" onclick=\"start()\">â†» ã‚‚ã†ã„ã¡ã©</button></div></div>`;
    // In teacher mode for hand writing, do not auto-save record. Wait for manual grading.
    if(mode === 'hand' && evalMethod === 'teacher'){
      // do nothing (records will be saved after grading)
    } else {
      const rec = buildRecord();
      saveRecord(rec);
    }
    if(recordPanel.style.display === 'block'){
      renderRecords();
    }
  }
  // Records
  const REC_KEY='kana_test_records_v1';
  function buildRecord(){ const now=new Date(); const ja=now.toLocaleString('ja-JP',{timeZone:'Asia/Tokyo'}); const wrongs=Array.from(wrongMap.entries()).map(([ch,n])=>({ch,n})).sort((a,b)=>b.n-a.n); return { date:ja, script,setKind,mode,total:queue.length,correct,wrong,maybe,wrongs }; }
  function saveRecord(rec){ try{ const arr=JSON.parse(localStorage.getItem(REC_KEY)||'[]'); arr.push(rec); if(arr.length>200) arr.shift(); localStorage.setItem(REC_KEY, JSON.stringify(arr)); }catch(e){} }
  function loadRecords(){ try{ return JSON.parse(localStorage.getItem(REC_KEY)||'[]'); }catch(e){ return []; } }
  function renderRecords(){
    // Clear current list
    recordList.innerHTML = '';
    // Only show past test records (aggregated)
    const arr = loadRecords().slice().reverse();
    if (!arr.length) {
      const p = document.createElement('div');
      p.textContent = 'ï¼ˆã¾ã  ãã‚ã ãŒ ã‚ã‚Šã¾ã›ã‚“ï¼‰';
      recordList.appendChild(p);
      return;
    }
    for (const r of arr) {
      const div = document.createElement('div');
      div.className = 'recItem';
      const d = document.createElement('details');
      d.innerHTML = `<summary>${r.date}ï½œ${labelScript(r.script)}ï½œ${labelSet(r.setKind)}ï½œ${labelMode(r.mode)}ï½œã€‡${r.correct} Ã—${r.wrong} â–³${r.maybe}</summary>`;
      const w = (r.wrongs && r.wrongs.length) ? r.wrongs.map(x => `${x.ch}:${x.n}`).join('ã€€') : 'ãªã—';
      const inner = document.createElement('div');
      inner.style.margin = '8px 0 0';
      inner.textContent = `ã¾ã¡ãŒãˆï¼š${w}`;
      d.appendChild(inner);
      div.appendChild(d);
      recordList.appendChild(div);
    }
  }

  // Render the list of pending submissions for teacher grading
  function renderPending() {
    if (!pendingList) return;
    pendingList.innerHTML = '';
    const pending = loadSubmissions();
    if (!pending || !pending.length) {
      const p = document.createElement('div');
      p.textContent = 'ï¼ˆæ¡ç‚¹å¾…ã¡ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰';
      pendingList.appendChild(p);
      return;
    }
    pending.forEach(sub => {
      const div = document.createElement('div');
      div.className = 'recItem';
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.gap = '8px';
      // thumbnail
      const img = document.createElement('img');
      img.src = sub.image;
      img.style.width = '60px';
      img.style.height = '60px';
      img.style.objectFit = 'contain';
      row.appendChild(img);
      // info text
      const info = document.createElement('div');
      info.style.flex = '1';
      info.textContent = `${sub.date}ï½œ${labelScript(sub.script)}ï½œ${labelSet(sub.setKind)}ï½œæ–‡å­—ï¼š${sub.char}`;
      row.appendChild(info);
      // grading buttons
      const btnGood = document.createElement('button');
      btnGood.className = 'nav-button';
      btnGood.textContent = 'ã€‡';
      btnGood.onclick = () => { gradeSubmission(sub, 'good'); };
      const btnBad = document.createElement('button');
      btnBad.className = 'nav-button';
      btnBad.textContent = 'Ã—';
      btnBad.onclick = () => { gradeSubmission(sub, 'bad'); };
      const btnBox = document.createElement('div');
      btnBox.style.display = 'flex';
      btnBox.style.gap = '4px';
      btnBox.appendChild(btnGood);
      btnBox.appendChild(btnBad);
      row.appendChild(btnBox);
      div.appendChild(row);
      pendingList.appendChild(div);
    });
  }
  function labelScript(s){ return s==='hira'?'ã²ã‚‰ãŒãª':'ã‚«ã‚¿ã‚«ãƒŠ'; }
  function labelSet(s){ return {seion:'æ¸…éŸ³',dakuon:'æ¿éŸ³',handakuon:'åŠæ¿éŸ³',yoon:'æ‹—éŸ³',all:'ãœã‚“ã¶'}[s]||s; }
  function labelMode(m){ return m==='choice'?'5æŠ':'æ‰‹æ›¸ã'; }
  function clearAllRecords(silent){
    try {
      // Remove records, submissions, and aggregator keys
      const keys = [REC_KEY, 'kana_test_records', 'kana_test_records_v0', SUB_KEY, AGG_KEY];
      for (const k of keys) {
        localStorage.removeItem(k);
      }
      // Reset modern record list to empty array
      localStorage.setItem(REC_KEY, '[]');
    } catch (e) {}
    if (!silent) alert('è¨˜éŒ²ã‚’æ¶ˆå»ã—ã¾ã—ãŸ');
    recordList.innerHTML = 'ï¼ˆã¾ã  ãã‚ã ãŒ ã‚ã‚Šã¾ã›ã‚“ï¼‰';
    pendingList.innerHTML = '';
    setTimeout(() => { renderRecords(); renderPending(); }, 0);
  }
  // Buttons
  startBtn.onclick=start;
  resetBtn.onclick=resetAll;
  playBtn.onclick=()=>{ if(current) speakKana(current); };
  replayBtn.onclick=()=>{ if(current) speakKana(current); };
  recordToggle.onclick=()=>{ recordPanel.style.display=(recordPanel.style.display==='block')?'none':'block'; if(recordPanel.style.display==='block') renderRecords(); };
  refreshRec.onclick=renderRecords;
  clearRec.onclick=()=>{ if(confirm('ãœã‚“ã¶æ¶ˆã—ã¾ã™ã‹ï¼Ÿ')) clearAllRecords(false); };

  // Toggle the grading pending panel
  if (pendingToggle) {
    pendingToggle.onclick = () => {
      pendingPanel.style.display = (pendingPanel.style.display === 'block') ? 'none' : 'block';
      if (pendingPanel.style.display === 'block') {
        renderPending();
      }
    };
  }

  // Submit button for teacher mode
  submitBtn.onclick = () => {
    if(!running) return;
    // Only work in teacher mode and hand writing
    if(mode !== 'hand' || evalMethod !== 'teacher') return;
    // Ensure canvas size
    ensureCanvasReady();
    // Create offscreen canvas to capture drawing
    const off = document.createElement('canvas');
    off.width = canvas.width;
    off.height = canvas.height;
    const oc = off.getContext('2d');
    // Fill white background
    oc.fillStyle = '#fff';
    oc.fillRect(0,0,off.width,off.height);
    oc.drawImage(canvas, 0, 0);
    const dataUrl = off.toDataURL('image/png');
    const now = new Date();
    const ja = now.toLocaleString('ja-JP', { timeZone:'Asia/Tokyo' });
    // Include a unique id for matching when grading later
    const sub = { id: Date.now().toString() + Math.random().toString(36).slice(2), sessionId: currentSessionId, total: currentTotal, date: ja, script, setKind, char: current, image: dataUrl };
    addSubmission(sub);
    // Reset current drawing and proceed to next question
    paths = [];
    currentPath = [];
    nextQuestion();
  };
  // Attach handler for the settings button. Show the dialog with fallback for browsers that lack showModal().
  openSettingsBtn.onclick = () => {
    const v = parseInt(localStorage.getItem('kana_leniency') || '4', 10) || 4;
    leniencyRange.value = String(v);
    lenVal.textContent = String(v);
    if (settingsDlg && typeof settingsDlg.showModal === 'function') {
      settingsDlg.showModal();
    } else if (settingsDlg) {
      // Fallback: mark the dialog as open and display it.
      settingsDlg.setAttribute('open', 'true');
      settingsDlg.style.display = 'block';
    }
  };
  leniencyRange.addEventListener('input',()=>{ lenVal.textContent=leniencyRange.value; });
  // Attach handler for saving settings. Persist leniency and close the dialog gracefully.
  saveSettingsBtn.onclick = (e) => {
    e.preventDefault();
    localStorage.setItem('kana_leniency', String(leniencyRange.value));
    if (settingsDlg && typeof settingsDlg.close === 'function') {
      settingsDlg.close();
    } else if (settingsDlg) {
      settingsDlg.removeAttribute('open');
      settingsDlg.style.display = 'none';
    }
  };
  // Init
  ensureCanvasReady(); redraw();
  </script>
</body>
</html>